# 第 10 章。最终思想

> “我们正在创造和雇用人员来填补“新领”职位–在网络安全，数据科学，人工智能和认知业务等领域扮演着全新的角色。”

– *Ginni Rometty* ，IBM 董事长兼首席执行官

再次感谢读者，祝贺您阅读这些长章节并尝试了部分或全部示例代码的漫长旅程。 我试图在深入研究特定主题的基础知识（例如深度学习或时间序列分析）与为从业者提供全面的示例代码之间提供良好的组合。 我特别希望您发现在单个 Jupyter Notebook 中将数据科学分析与 PixieApp 应用程序编程模型紧密集成的想法有趣且新颖。 但是，最重要的是，我希望您发现它有用，并且可以在您自己的项目中以及与您自己的团队一起重用。

在第 1 章，*开发人员对数据科学的观点*的开头，我使用了 Drew's Conway Venn 图（这是我的最爱之一）来表示什么是数据科学。 以及为什么数据科学家被广泛认为是独角兽。 考虑到 Drew Conway 的所有方面，我想扩展此图，以表示开发人员在数据科学领域的重要且不断增长的作用，如下图所示：

![Final Thoughts](img/00258.jpeg)

Drew 的数据科学 Conway Venn 图现在包括开发人员

我现在想利用上一章的内容对未来以及对 AI 和数据科学的期望发表自己的看法。

# 前瞻性思维-对 AI 和数据科学的期望

这是我非常喜欢的部分，因为我无需表达准确性就可以表达前瞻性意见，因为根据定义，这些只是我的观点![Forward thinking – what to expect for AI and data science](img/00259.jpeg)。

正如我在第 1 章，*开发人员对数据科学的观点*中所解释的那样，我相信 AI 和数据科学将继续存在，它们将继续对现有行业造成破坏。 在可预见的未来，最有可能以加速的速度发展。 这肯定会影响工作的总数，并且类似于我们过去看到的其他技术革命（农业，工业，信息等），有些将消失，而新的将被创造。

2016 年，IBM 董事长兼首席执行官 Ginny Rometty 在[致唐纳德·特朗普总统的一封信](https://www.ibm.com/blogs/policy/ibm-ceo-ginni-romettys-letter-u-s-president-elect)中，讨论了通过创建她称为“新领”的新型工作来更好地为 AI 革命做准备的需要，如以下摘录所示：

> “在当今的 IBM 工作并不总是需要大学学位；在我们美国的一些中心，多达三分之一的员工不到四年制学位。最重要的是相关技能，有时会获得 此外，我们正在创造和雇用人员来填补“新领”职位-在网络安全，数据科学，人工智能和认知业务等领域扮演全新角色。”

如果我们成功地实现了数据科学的民主化，那么这些“新领子”工作就只能创造足够的数量，因为数据科学是 AI 的命脉，每个人都需要以某种能力参与进来； 开发人员，业务线用户，数据工程师等。 不难想象，对这些新型工作的需求将如此之大，以至于传统的学术途径将无法满足需求。 相反，该行业将有责任通过制定旨在重新培训所有可能面临裁员风险的现有工人的新计划来填补这一空白。 将会出现[类似于 Apple 的 *Everyone Can Code* 程序的新程序](https://www.apple.com/everyone-can-code)； 也许像*之类的任何人都可以做数据科学*。 我还认为 **MOOC**（**大规模开放在线课程**的缩写）将发挥更大的作用，今天，由于主要 MOOC 参与者之间建立了许多合作关系， 例如 Coursera 和 edX，以及像 IBM 这样的公司（请参阅[这个页面](https://www.coursera.org/ibm)）。

公司还可以做其他事情，以便更好地为 AI 和数据科学革命做准备。 在第 1 章和*开发人员对数据科学的观点*中，我讨论了数据科学策略的三个支柱，它们可以帮助我们实现这一宏伟的目标：数据 ，服务和工具。

在服务方面，公有云的高速增长在很大程度上促进了多个领域的高质量服务的整体增长：数据持久性，认知，流传输等。 亚马逊，Facebook，谷歌，IBM 和 Microsoft 等提供商在以服务为先的方法以及强大的平台支持下为服务开发者提供一致体验的创新能力建设中发挥着领导作用。 随着越来越多的强大服务以越来越快的速度发布，这一趋势将继续加速。

一个很好的例子是称为 [AlphaZero](https://en.wikipedia.org/wiki/AlphaZero) 的 Google 自学习 AI，它在 4 小时内自学了国际象棋，并继续击败冠军 国际象棋程序。 另一个很好的例子来自 IBM 最近宣布的[辩论者项目](https://www.research.ibm.com/artificial-intelligence/project-debater)，这是第一个可以对人类进行辩论的 AI 系统。 复杂的话题。 这些类型的进步将继续推动越来越多的强大服务的可用性，包括开发人员在内的每个人都可以使用它。 聊天机器人是已成功实现民主化的服务的另一个示例，因为开发人员从未如此轻松地创建包含对话功能的应用程序。 我相信，随着时间的流逝，使用这些服务将变得越来越容易，使开发人员能够构建令人惊奇的新应用程序，而这些我们今天甚至还无法想象。

在数据方面，我们需要比现在更轻松地访问高质量数据。 我想到的一个模型来自电视节目`24`。 全面披露; 我喜欢看电视并喜欢看电视连续剧，我认为其中一些可以很好地指示技术发展的方向。 在`24`中，反恐特工杰克·鲍尔（Jack Bauer）有 24 小时制止坏人造成灾难性事件。 看着那个节目，我总是惊讶于数据从指挥中心的分析员传回杰克鲍尔的手机如此容易，或者给定仅需几分钟即可解决的数据问题， 分析人员能够召集来自不同系统（卫星图像，记录系统等）的数据，对坏蛋进行零介入； 例如，我们正在寻找最近 2 个月内在指定半径内购买了此类化学品的人。 哇！ 从我的角度来看，这就是数据科学家访问和处理数据应该多么容易且毫不费力。 我相信我们通过诸如 Jupyter Notebook 之类的工具在朝着这个目标迈进，该工具充当控制平面，用于将数据源与处理它们的服务和分析相连接。 Jupyter Notebook 将工具带到了数据中，而不是相反，从而大大降低了想要参与数据科学的任何人的入门成本。

# 参考

*   [DeepQA（IBM）](https://researcher.watson.ibm.com/researcher/view_group_subpage.php?id=2159)
*   [*Watson 中的深度解析*， *McCord* ， *Murdock* ， *Boguraev* ](http://brenocon.com/watson_special_issue/03%20Deep%20parsing.pdf)
*   [*Jupyter for Data Science* ， *Dan Toomey* ， *Packt Publishing* ](https://www.packtpub.com/big-data-and-business-intelligence/jupyter-data-science)
*   [PixieDust 文档](https://pixiedust.github.io/pixiedust/)
*   [*您一直想要的 Jupyter 笔记本的 Visual Python 调试器*， *David Taieb* ](https://medium.com/ibm-watson-data-lab/the-visual-python-debugger-for-jupyter-notebooks-youve-always-wanted-761713babc62)
*   [*在网络上共享 Jupyter 笔记本图表*， *David Taieb* ](https://medium.com/ibm-watson-data-lab/share-your-jupyter-notebook-charts-on-the-web-43e190df4adb)
*   [*使用 PixieDust 1.1 版*， *David Taieb* ](https://medium.com/ibm-watson-data-lab/deploy-your-analytics-as-web-apps-using-pixiedusts-1-1-release-d08067584a14)
*   [Kubernetes](https://kubernetes.io/docs/home/)
*   [字云](https://amueller.github.io/word_cloud/index.html)
*   [*神经网络与深度学习*， *Michael Nielsen* ](http://neuralnetworksanddeeplearning.com/index.html)
*   [*深度学习*，*伊恩·古德费洛*， *Yoshua Bengio* 和 *Aaron Courville* ，*麻省理工学院出版社*](http://www.deeplearningbook.org/)
*   [TensorFlow 文档站点](https://www.tensorflow.org/)
*   [*TensorFlow For Poets* ](https://codelabs.developers.google.com/codelabs/tensorflow-for-poets)
*   [*Tensorflow 和深度学习-没有博士学位，MartinGörner*](https://www.youtube.com/watch?v=vq2nnJ4g6N0)
*   [Apache Spark](https://spark.apache.org/)
*   [Tweepy 库文档](http://tweepy.readthedocs.io/en/latest/)
*   [*Watson Developer Cloud Python SDK* ](https://github.com/watson-developer-cloud/python-sdk)
*   [Kafka-Python](https://kafka-python.readthedocs.io/en/master/usage.html)
*   [*使用 Spark* ， *David Taieb* 的 Twitter Hashtag 的情感分析](https://medium.com/ibm-watson-data-lab/real-time-sentiment-analysis-of-twitter-hashtags-with-spark-7ee6ca5c1585)
*   [*使用统计和机器学习模型的时间序列预测*， *Jeffrey Yau* ](https://www.youtube.com/watch?v=_vQ0W_qXMxk)
*   [*时间序列预测理论*， *Analytics University* ](https://www.youtube.com/watch?v=Aw77aMLj9uM)
*   [*时间序列分析-PyCon 2017* ， *Aileen Nielsen* ](https://www.youtube.com/watch?v=zmfe2RaX-14)
*   [Quandl Python 文档](https://docs.quandl.com/docs/python)
*   [Statsmodels 文档](https://www.statsmodels.org/stable/index.html)
*   [NetworkX](https://networkx.github.io/documentation/networkx-2.1/index.html) 
*   [GeoJSON 规范](http://geojson.org/)
*   [*Beautiful Soup 文档*](https://www.crummy.com/software/BeautifulSoup/bs4/doc)

# 附录 A.PixieApp 快速参考

本附录是开发人员快速参考指南，提供了所有 PixieApp 属性的摘要。

# 批注

*   `@PixieApp`: 必须添加到任何 PixieApp 类的类注释。

    参数：无

    例子：

    ```py
    from pixiedust.display.app import *
    @PixieApp
    class MyApp():
        pass
    ```

*   `@route`: 需要使用方法注释来表示方法（可以具有任何名称）与路由相关联。

    参数：`**kwargs`。 表示路由定义的关键字参数（键值对）。 PixieApp 调度程序将根据以下规则将当前内核请求与路由进行匹配：

    *   参数数量最多的路由将首先被评估。
    *   所有参数都必须匹配才能选择路由。 参数值可以使用`*`表示任何值都将匹配。
    *   如果未找到路由，则选择默认路由（不带参数的路由）。
    *   route 参数的每个键可以是过渡状态（由`pd_options`属性定义），也可以是持久状态（PixieApp 类的字段，在显式更改之前一直存在）。
    *   该方法可以具有任意数量的参数。 调用方法时，PixieApp 调度程序将尝试将方法参数与具有相同名称的路由参数进行匹配。

    返回值：该方法必须返回将注入到前端的 HTML 片段（除非使用`@captureOutput`批注）。 该方法可以利用 Jinja2 模板语法生成 HTML。 HTML 模板可以访问一定数量的变量：

    *   **此**：引用 PixieApp 类（请注意，由于 Jinja2 框架本身已使用`self`，因此我们使用`this`代替了`self`）
    *   **前缀**：PixieApp 实例唯一的字符串 ID
    *   **实体**：请求的当前数据实体
    *   **方法参数**：可以在 Jinja2 模板中以变量形式访问方法的所有参数

        ```py
        from pixiedust.display.app import *
        @PixieApp
        class MyApp():
            @route(key1=”value1”, key2=”*”)
            def myroute_screen(self, key1, key2):
                return “<div>fragment: Key1 = {{key1}} - Key2 = {{key2}}”
        ```

    例子：

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode25.py)。

*   `@templateArgs`: 允许在 Jinja2 模板中使用任何局部变量的注释。 请注意，不能将`@templateArgs`与`@captureOutput`结合使用：

    参数：无

    例子：

    ```py
    from pixiedust.display.app import *
    @PixieApp
    class MyApp():
        @route(key1=”value1”, key2=”*”)
        @templateArgs
        def myroute_screen(self, key1, key2):
            local_var = “some value”
            return “<div>fragment: local_var = {{local_var}}”
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/T4houghtful-Data-Science/blob/master/chapter%205/sampleCode26.py)。

*   `@captureOutput`: 可以使用路由方法更改合同的注释，这样就不必再返回 HTML 片段。 相反，方法主体可以像在 Notebook 单元中那样简单地输出结果。 该框架将捕获输出并将其作为 HTML 返回。 请注意，在这种情况下，您不能使用 Jinja2 模板。

    参数：无

    例子：

    ```py
    from pixiedust.display.app import *
    import matplotlib.pyplot as plt
    @PixieApp
    class MyApp():
        @route()
        @captureOutput
        def main_screen(self):
            plt.plot([1,2,3,4])
            plt.show()
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode27.py)。

*   `@Logger`: 通过向类中添加日志记录方法来添加日志记录功能：`debug`, `warn`, `info`, `error`, `critical`, `exception`。

    参数：无

    例子：

    ```py
    from pixiedust.display.app import *
    from pixiedust.utils import Logger
    @PixieApp
    @Logger()
    class MyApp():
        @route()
        def main_screen(self):
            self.debug(“In main_screen”)
            return “<div>Hello World</div>”
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode28.py)。

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode28.py)。

# 自定义 HTML 属性

这些可以与任何常规 HTML 元素一起使用以配置内核请求。 当元素接收到点击或更改事件时，或者在 HTML 片段完成加载后，PixieApp 框架可以触发这些请求。

*   `pd_options`: 根据以下格式定义用于内核请求的瞬时状态的键值对列表：`pd_options=”key1=value1;key2=value2;...”`。 当与`pd_entity`属性结合使用时，`pd_options`属性将调用 PixieDust `display()`API。 在这种情况下，您可以从使用`display()` API 的单独 Notebook 单元的元数据中获取值。 当在`display()`模式下使用`pd_options`时，为方便起见，建议通过创建名为`<pd_options>`的子元素并使用 JSON 值作为文本来使用`pd_options`的 JSON 表示法。

    以`pd_options`作为子元素调用`display()`的示例：

    ```py
    <div pd_entity>
        <pd_options>
            {
                “mapboxtoken”: “XXXXX”,
                “chartsize”: “90”,
                “aggregation”: “SUM”,
                “rowCount”: “500”,
                “handlerId”: “mapView”,
                “rendererId”: “mapbox”,
                “valueFields”: “IncidntNum”,
                “keyFields”: “X,Y”,
                “basemap”: “light-v9”
            }
        </pd_options>
    </div>
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode29.html)。

    以`pd_options`作为 HTML 属性的示例：

    ```py
    <!-- Invoke a route that displays a chart -->
    <button type=”submit” pd_options=”showChart=true” pd_target=”chart{{prefix}}”>
        Show Chart
    </button>
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode30.html)。

*   `pd_entity`：仅用于在特定数据上调用`display()` API。 必须与`pd_options`结合使用，其中键值对将用作`display()`的参数。 如果未为`pd_entity`属性指定任何值，则假定该实体为传递给启动 PixieApp 的`run`方法的实体。 `pd_entity`值可以是在 Notebook 中定义的变量或 PixieApp 的字段（例如`pd_entity=”df”`），也可以是使用点表示法的对象的字段（例如`pd_entity=”obj_instance.df”`）。
*   `pd_target`: 默认情况下，内核请求的输出会注入到整个输出单元格或对话框中（如果您使用`runInDialog = "true"`作为`run`方法的参数）。 但是，您可以使用`pd_target = "elementId"`指定将接收输出的目标元素。 （请注意，`elementId`必须存在于当前视图中。）

    例子：

    ```py
    <div id=”chart{{prefix}}”>
    <button type=”submit” pd_options=”showChart=true” pd_target=”chart{{prefix}}”>
        Show Chart
    </button>
    </div>
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode31.html)。

*   `pd_script`: 这将调用任意 Python 代码作为内核请求的一部分。 可以与其他属性（例如 pd_entity 和 pd_options）结合使用。 请务必注意，必须遵守 [Python 缩进规则](https://docs.python.org/2.0/ref/indentation.html)以避免运行时错误。

    如果 Python 代码包含多行，建议使用`pd_script`作为子元素并将代码存储为文本。

    例子：

    ```py
    <!-- Invoke a method to load a dataframe before visualizing it -->
    <div id=”chart{{prefix}}”>
    <button type=”submit”
        pd_entity=”df”
        pd_script=”self.df = self.load_df()”
        pd_options=”handlerId=dataframe”
        pd_target=”chart{{prefix}}”>
        Show Chart
    </button>
    </div>
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode32.html)。

*   `pd_app`: 这将通过其完全限定的类名称动态调用一个单独的 PixieApp。 `pd_options`属性可用于传递路由参数以调用 PixieApp 的特定路由。

    例子：

    ```py
    <div pd_render_onload
         pd_option=”show_route_X=true”
         pd_app=”some.package.RemoteApp”>
    </div>
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode33.html)。

*   `pd_render_onload`: 与用户单击元素或发生更改事件时相反，这应用于在加载时触发内核请求。 `pd_render_onload`属性可以与定义请求的任何其他属性组合，例如`pd_options`或`pd_script`。 请注意，此属性仅应与`div`元素一起使用。

    例子：

    ```py
    <div pd_render_onload>
        <pd_script>
    print(‘hello world rendered on load’)
        </pd_script>
    </div>
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode34.html)。

*   `pd_refresh`: 即使没有事件（单击或更改事件）发生，它也用于强制 HTML 元素执行内核请求。 如果未指定任何值，则刷新当前元素，否则，将刷新具有在值中指定的 ID 的元素。

    例子：

    ```py
    <!-- Update state before refreshing a chart -->
    <button type=”submit”
        pd_script=”self.show_line_chart()”
        pd_refresh=”chart{{prefix}}”>
        Show line chart
    </button>
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode35.html)。

*   `pd_event_payload`: 这将发出具有指定有效内容的 PixieApp 事件。 该属性遵循与`pd_options`相同的规则：

    *   每个键值对必须使用`key=value`表示法进行编码
    *   该事件将在点击或更改事件时触发
    *   支持`$val()`指令以动态注入用户输入的输入
    *   使用`<pd_event_payload>`子项输入原始 JSON。

        ```py
        <button type=”submit” pd_event_payload=”type=topicA;message=Button clicked”>
            Send event A
        </button>
        <button type=”submit”>
            <pd_event_payload>
            {
                “type”:”topicA”,
                “message”:”Button Clicked”
            }
            </pd_event_payload>
            Send event A
        </button>
        ```

    例子：

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode36.html)。

*   `pd_event_handler`: 订阅者可以通过声明一个`<pd_event_handler>`子元素来监听事件，该子元素可以接受任何 PixieApp 内核执行属性，例如`pd_options`和`pd_script`。 这个元素必须使用`pd_source`属性来过滤他们想要处理的事件。 `pd_source`属性可以包含以下值之一：

    *   `targetDivId`：仅接受来自具有指定 ID 的元素的事件
    *   `type`：仅接受具有指定类型的事件。

        ```py
        <div class=”col-sm-6” id=”listenerA{{prefix}}”>
            Listening to button event
            <pd_event_handler
                pd_source=”topicA”
                pd_script=”print(eventInfo)”
                pd_target=”listenerA{{prefix}}”>
            </pd_event_handler>
        </div>
        ```

    例子：

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode37.html)。

    **注意**：将`pd_source`用作`*`表示将接受所有事件。

*   `pd_refresh_rate`: 这用于以毫秒为单位的指定间隔重复执行元素。 当您要轮询特定变量的状态并在 UI 中显示结果时，这很有用。

    例子：

    ```py
    <div pd_refresh_rate=”3000”
        pd_script=”print(self.get_status())”>
    </div>
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode38.html)。

# 方法

*   `setup`: 这是由 PixieApp 实现的用于初始化其状态的可选方法。 在 PixieApp 运行之前将被自动调用。

    参数：无

    例子：

    ```py
    def setup(self):
        self.var1 = “some initial value”
        self.pandas_dataframe = pandas.DataFrame(data)
    ```

    ### 注意

    [您可以在此处找到代码文件](https://github.com/DTAIEB/Thoughtful-Data-Science/blob/master/chapter%205/sampleCode39.py)。

*   `run`: 这将启动 PixieApp。

    参数：

    *   **实体**：[可选]数据集作为输入传递到 PixieApp。 可以用`pd_entity`属性引用，也可以直接作为`pixieapp_entity`字段引用。
    *   **** kwargs**：运行时传递给 PixieApp 的关键字参数。 例如，使用`runInDialog=”true”`将在对话框中启动 PixieApp。

        ```py
        app = MyPixieApp()
        app.run(runInDialog=”true”)
        ```

    例子：

*   `invoke_route`: 这用于以编程方式调用路由。

    参数：

    *   **路由方法**：要调用的方法。
    *   **** kwargs**：要传递给 route 方法的关键字参数。

        ```py
        app.invoke_route(app.route_method, arg1 = “value1”, arg2 = “value2”)
        ```

    例子：

*   `getPixieAppEntity`：用于检索调用`run()`方法时传递的当前 PixieApp 实体（可以为 None）。 通常从 PixieApp 内部调用`getPixieAppEntity()`，即：

    ```py
    self.getPixieAppEntity()
    ```